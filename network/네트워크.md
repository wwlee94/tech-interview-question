# 네트워크 ( Network )

### OSI 7 계층
* 7계층은 왜 나눌까? - 통신이 일어나는 과정을 단계별로 알 수 있고, 특정한 곳에 이상이 생기면 그 단계만 수정할 수 있기 때문

1. 물리 ( Physical ) 계층 
    - 리피터, 케이블, 허브 등 
    - 데이터를 전기적인 신호로 변환해서 전송하는 역할
2. 데이터 링크 ( Data Link ) 계층
    - 브릿지, 스위치 등 
    - Mac 주소를 통해 프레임 통신
3. 네트워크 ( Network ) 계층 
    - 라우터, IP 
    - 라우터를 통해 이동할 경로를 선택하여 IP 주소를 지정, 해당 경로로 패킷 전달
4. 트랜스포트 ( Transport ) 계층 
    - TCP, UDP
    - TCP와 UDP 프로토콜을 통해 통신 활성화. 포트를 열어두고, 프로그램들이 전송 할 수 있도록
        * TCP: 신뢰성, 연결성 ( 웹 HTTP 통신, 이메일, 파일 전송 등 )
        * UDP: 비신뢰성, 비연결성, 실시간 , 신속성 ( 실시간 서비스, 온라인 게임, DNS 등 )
5. 세션 ( Session ) 계층
    - API, Socket
    - 데이터가 통신하기 위한 논리적 연결을 담당
6. 표현 ( Presentation ) 계층
    - JPEG, MPEG 등
    - 파일 인코딩, 압축, 암호화 담당
7. 응용 ( Application ) 계층
    - HTTP, FTP, DNS 등
    - 사용자 인터페이스, 데이터베이스 관리 등의 서비스를 제공

### TCP 3 way handshake & 4 way handshake
* 3 way handshake - 연결 성립 과정 
    * 서버로 연결 요청하고 / 서버도 알았다 클라에게 보내고 / 클라는 서버로 확인 요청 보냄
* 4 way handshake - 연결 해제 과정 
    * 서버로 연결 해제 요청 / 서버도 알았다 클라에게 보냄 + 데이터를 다 보내고 나서 데이터를 다 보냈다고 보냄 / 클라는 서버로 확인 요청 보냄

### 대칭키 & 공개키
#### 대칭키 ( Symmetric Key )
암호화, 복호화에 같은 암호키(대칭키)를 사용하는 알고리즘
* 장점
    - 동일한 키를 주고 받기 때문에, 매우 빠르다 ! But, 해킹 위험에 노출 

#### 공개키 ( Public Key )
암호화, 복호화에 사용하는 암호키를 분리한 알고리즘
- 자신이 가지고 있는 고유한 암호키 (비밀키) 로만 복호화 할 수 있는 암호키 (공개키)를 대중에 공개함
    * 장점: 보안 ↑ But, 매우 복잡함 
#### 대칭키와 공개키 암호화 방식을 적절히 혼합하면?
- SSL 탄생의 시초 ( Secure Socket Layer )
- 웹서버와 브라우저 간의 보안을 위해 만든 프로토콜

#### 동작 순서
1. A가 B의 공개키로 암호화 통신에 사용할 대칭키를 암호화하고 B에게 보냄
2. B는 암호문을 받고, 자신의 비밀키로 복호화함
3. B는 A로부터 얻은 대칭키로 A에게 보낼 평문을 암호화하여 A에게 보냄
4. A는 자신의 대칭키로 암호문을 복호화함
5. 앞으로 이 대칭키로 암호화를 통신함   
즉, 처음 대칭키를 주고 받을 때만 공개키 암호화를 사용하고 이후에는 계속 대칭키 암호화 방식으로 통신 !

### HTTP & HTTPS
* HTTP ( HyperText Transfer Protocol )
- 인터넷 상에서 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약
- 단점: HTTP는 텍스트 교환이므로, 누군가 네트워크에서 신호를 가로채면 내용이 노출됨 -> 보안 이슈 -> 이러한 문제는 'HTTPS' 로 해결

* HTTPS ( HyperText Transfer Protocol Secure )
- 인터넷 상에서 정보를 암호화하는 SSL 프로토콜을 사용해 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약
- HTTPS는 텍스트를 암호화한다. ( 공개키 암호화 방식으로 ! )
- 대신, 암호화하는 과정 때문에 상대적으로 느림

### 로드 밸런싱 ( Load Balancing )
* 서버를 여러개로 늘려서 성능을 향상 시키는 Scale-Out시 여러 서버에게 균등하게 트래픽을 분산시켜주는 것이 로드 밸런싱 !
* 분산 방법
    * 라운드 로빈(Round Robin) : CPU 스케줄링의 라운드 로빈 방식 활용 -> 시분할 선점형 스케줄링으로 우선순위를 두지 않고, 정해진 시간단위로 CPU를 할당하는 방식
    * Least Connections : 연결 개수가 가장 적은 서버 선택 (트래픽으로 인해 세션이 길어지는 경우 권장)ㄴ
    * Source : 사용자 IP를 해싱하여 분배 (특정 사용자가 항상 같은 서버로 연결되는 것 보장)