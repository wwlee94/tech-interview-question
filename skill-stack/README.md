# 기술 스택

### Web Assembly (WA)
* Go, Rust, Kotlin 같은 언어들을 브라우저가 이해할 수 있는 코드로 컴파일 해주는 환경
* 언어와 웹, 앱의 경계가 사라짐 -> js가 더 필요 없어짐
* 브라우저에서 실행되니 다운로드 환경도 없어짐

### Electron
* html, css, js 를 가져다가 컴파일해서 윈도우,맥,리눅스(설치 가능한) 소프트웨어로 만들어줌
* Ex) VSC, Slack, Github, Atom, Skype ...

### Git
* 버전 관리 툴 - 깃은 같은 파일에 대한 각기 다른 버전을 보관할 수 있다.
* 파일의 변경사항을 각기 다른 파일에 한번에 적용 할 수 있게 도와줌 ( 효율성 )
* 협업도 가능   
-> 각 에디터의 변경사항과 충돌하지 않도록 -> How? -> 깃허브 등장 (클라우드에 있는 깃 제공자)  
-> 자신의 깃 히스토리를 클라우드 서버에 올릴 수 있어서 협업이 가능한 것 !

### AWS EC2 와 Heroku
* AWS EC2 (Infrastructure as a service) -> (인프라 == 서버)  -> Iaas
    * 사용자가 서버를 빌려서 알아서 설치하거나 업데이트 해야함
    * 버전에 대한 컨트롤 ↑ 
    * 개발 시간 빠르지 않음
    * 가격 ↓ 
* Heroku (Platform as a service) -> Paas
    * 코드만 업로드하면 플랫폼이 이를 이해해서 설치해줌
    * 버전에 대한 컨트롤 ↓
    * 개발 시간 절약 가능
    * 가격 ↑ - 헤로쿠는 AWS 위에서 돌아가서 -> 인프라 + 플랫폼 가격이니 더 비쌈

* AWS EB (Beanstalk) - AWS의 Platform as a service -> 헤로쿠의 직접적인 경쟁 상대   
-> but, 여전히 헤로쿠가 더 쉽고 빠르다. But, 헤로쿠가 더 비쌈
* 버전에 대한 컨트롤이란?
    *  Ex) 어떤 버전의 언어를 사용할지, apache or nginx 를 쓸지,  
    포트를 열지 말지 등등 에 대한 선택권이 없음
* 번외 : Saas란? (Software as a service) -> 호스팅 방식으로 소프트웨어를 제공하는 것

### Javascript의 Webpack과 Babel
#### Webpack
* JavaScript는 언어 자체가 지원하는 모듈 시스템이 없음 -> 이런 한계를 극복하려 여러 가지 도구를 활용하는데 그 도구 가운데 하나가 Webpack
#### Babel
* Babel은 오래된 브라우저에도 ES6를 사용 할 수 있도록 ES5로 변경해주는 트랜스 컴파일러이다.

### Serverless (서버리스)
* 과거엔 개발자들이 하드웨어, 소프트웨어 모두를 관리, 최근엔 AWS의 EC2 등 클라우드 서비스로 하드웨어 관리를 해주는 서비스   
    -> 개발자들은 서버의 소프트웨어만 관리 -> 주기적으로 요청이 들어 오지 않는 서버는 비용 부담이 큼 -> 서버리스 등장  
    -> 코드만 저장한 뒤 필요할 때 이 코드를 실행시켜줌  
    -> 하드웨어, 소프트웨어(서버) 관리가 필요 없음 -> 그래서 서버리스 !! -> 사용한 만큼 금액을 지불함

### Redis ( Remote Dictionary System )
* 메모리를 이용하여 고속으로 <key, value> 스타일의 데이터를 저장하고 불러올 수 있는 시스템
* Key 와 Value
    * Key는 간결하면서도 중복되지 않아야하는 특성
    * Value는 string, sets, sorted-sets, hashes, lists 가 있음
* Expire 설정
    * Expire ( 만료시간 ) 설정을 해주어야함 -> 빠르지만 제한된 메모리가 감당할 수 없기 때문에 반드시 사용해야함   
    -> But, 메모리가 오버되면 시간 설정안해도 자동으로 제거함

### JWT ( JSON Web Token )
* 정보를 안전하게 전송하기 위해 공개된 표준
* JWT 구조
    * Header(헤더), Payload (페이로드) , Signature (서명)  3개의 파트가 '.' (dot) 에 구분됨
* 사용하는 이유?
    * 독립적  : 사용자 인증에 필요한 모든 정보는 토큰 자체에 포함 -> 별도의 인증 저장소가 필요없음
    * 서버 자원, 비용 절감 가능
        * 사용자가 로그인 되었는지 확인할 필요가 없고, 사용자가 요청을 했을 때 토큰만 확인하면 됨  
         -> 세션관리 필요 없음 -> 서버 자원, 비용 절감할 수 있음
    * 보안 이슈 ↑
        * Token을 인증 값으로 사용하게 되면 기존 쿠키/세션보다 많은 보안 이슈를 막을 수 있음 
        * JWT는 Signature으로 메시지가 중간에 변경되지 않음을 검증해준다